# OCaml Blossom Server 並行・並列処理設計書

## 1. 概要
OCaml 5のMulticore機能とEioライブラリを活用し、高パフォーマンスかつ安全なBlossomサーバーの並行・並列処理モデルを設計します。
Blossomサーバーのワークロードは主に「I/Oバウンド（ディスク読み書き、ネットワーク）」ですが、一部「CPUバウンド（ハッシュ計算、画像処理）」なタスクも存在します。これらを適切に分離し、効率的に処理します。

## 2. 並行処理 (Concurrency) - I/Oバウンド
HTTPリクエストのハンドリングやファイルI/Oは、**EioのFiber（軽量スレッド）** を用いて並行処理します。

*   **Piafの役割**: Piafは内部でEioを使用しており、各HTTP接続・リクエストを個別のFiberで処理します。これにより、多数のクライアントからの同時接続を1つのドメイン（OSスレッド）上で効率的にさばくことができます（C10K問題への対応）。
*   **ファイル操作**: `Eio.Path` モジュールを使用し、ブロッキングしないファイル読み書きを行います。
*   **設計方針**: 基本的なリクエスト処理（GET, HEAD, PUT /upload）は、メインのドメイン上のFiberで実行します。これにより、ドメイン間通信のオーバーヘッドを回避します。

## 3. 並列処理 (Parallelism) - CPUバウンド
CPUリソースを大量に消費する処理は、**EioのDomain（OSスレッド）** を用いて並列化し、メインのイベントループをブロックしないようにします。

### 3.1. 対象となる処理
*   **SHA256ハッシュ計算**: 大容量ファイル（数百MB〜GB単位）のアップロード時、ハッシュ計算がメインスレッドをブロックする可能性があります。
*   **メディア最適化 (BUD-05)**: 画像のリサイズや動画のトランスコードはCPU負荷が高いため、必ず別ドメインで実行する必要があります。
*   **署名検証**: 多数の署名検証が集中する場合。

### 3.2. 実装パターン: Worker Pool
ドメインの作成はコストが高いため、リクエストごとにドメインを作成するのではなく、**Worker Pool (`Eio.Executor_pool`)** を使用します。

```ocaml
(* 概念コード *)
let pool = Eio.Executor_pool.create ~sw ~domain_count:4 domain_mgr

let handle_heavy_task task =
  Eio.Executor_pool.submit pool (fun () ->
    (* CPU集約的な処理 *)
    process_media task
  )
```

*   **推奨設定**: `domain_count` はサーバーの物理コア数に合わせて調整します（例: コア数 - 1）。
*   **タスクの粒度**: 数ミリ秒（2-5ms）以上かかる処理のみをプールに投げます。それ以下の処理はオーバーヘッドの方が大きくなるため、メインドメインで処理します。

## 4. 状態管理と安全性 (State Management)
マルチコア環境では、複数のドメインが共有メモリにアクセスする際の競合（Data Race）に注意が必要です。

### 4.1. 共有リソース
*   **Blobインデックス**: アップロードされたBlobのメタデータ（SQLiteなど）へのアクセス。
*   **一時ファイル**: アップロード中のファイル。

### 4.2. 安全性確保の方針
1.  **Immutable Data**: 可能な限り不変データ構造を使用し、共有を安全にします。
2.  **Eio.Mutex / Eio.Semaphore**: 共有リソース（例: SQLite接続）へのアクセスは、Eioが提供する同期プリミティブで保護します。
3.  **Saturn (Lock-free Data Structures)**: 高頻度でアクセスされる共有キューなどが必要な場合は、`Saturn` ライブラリの使用を検討します。
4.  **メッセージパッシング**: ドメイン間でデータを共有する代わりに、`Eio.Stream` などを用いてデータを渡す設計を優先します。

## 5. 具体的な適用箇所 (Phase別)

### Phase 1 & 2 (基本機能)
*   **GET / PUT**: 基本的にメインドメインのFiberで処理。
*   **ハッシュ計算**:
    *   **ストリーミング処理**: アップロード時は `Piaf.Body` からのストリームを読み込みながら、`Digestif` でインクリメンタルにハッシュを計算しつつファイルに書き込みます。これはI/O待ちが発生するため、Eioのスケジューリングと相性が良く、基本的にはメインドメインで問題ありません。
    *   **検証用**: 保存済みファイルのハッシュ再計算など、純粋なCPUタスクとして実行する場合は `Eio.Executor_pool` にオフロードします。

### Phase 3 (認証)
*   **署名検証 (NIP-98)**:
    *   Ed25519/Schnorr署名の検証は計算コストがかかります（1回あたり数十マイクロ秒〜）。
    *   大量のリクエスト（DDoS攻撃など）が来た場合、メインループをブロックする恐れがあります。
    *   **対策**: `Verifier` モジュールを作成し、検証処理を `Eio.Executor_pool` に投入して `Eio.Promise` で結果を待つ設計にします。

### Phase 4+ (拡張)
*   **BUD-05 (Media)**:
    *   **外部プロセス方式**: `ffmpeg` や `imagemagick` を `Eio.Process.spawn` で呼び出します。これはI/Oバウンドとして扱えますが、CPUリソースを消費するため、同時実行数をセマフォ (`Eio.Semaphore`) で制限します。
    *   **ライブラリ方式**: OCamlの画像処理ライブラリ（`bimage`など）を使用する場合は、完全にCPUバウンドとなるため、必ず `Eio.Executor_pool` で実行します。

## 6. まとめ
*   **I/O**: Fiber (Eio)
*   **CPU**: Domain (Eio.Executor_pool)
*   **Safety**: Mutex, Immutable, Message Passing

この設計により、高スループット（I/O並行）と低レイテンシ（CPU並列）を両立させます。
